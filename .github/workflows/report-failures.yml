name: C# failure reporter

on:
    workflow_run:
        workflows: ["C# tests"]
        types: [completed]
        branches: [jbrinkman/matrix-errors]

permissions:
    actions: read
    contents: read
    issues: write

jobs:
    report:
        # Only handle scheduled runs or manual full-matrix runs ("C# Matrix Tests") that ended in failure
        if: github.event.workflow_run.conclusion == 'failure' && (github.event.workflow_run.event == 'schedule' || github.event.workflow_run.display_title == 'C# Matrix Tests')
        runs-on: ubuntu-latest
        steps:
            - name: Download artifacts from triggering run
              uses: dawidd6/action-download-artifact@v6
              with:
                  run_id: ${{ github.event.workflow_run.id }}
                  path: downloaded

            - name: Aggregate failures
              id: aggregate
              shell: bash
              run: |
                  set -euo pipefail
                  if ! command -v jq >/dev/null 2>&1; then
                    sudo apt-get update -y >/dev/null 2>&1 || true
                    sudo apt-get install -y jq >/dev/null 2>&1 || true
                  fi
                  shopt -s globstar nullglob
                  total_failed=0
                  total_suites=0
                  md='<!-- run:${{ github.event.workflow_run.id }} -->\n'
                  md+="# Nightly CI failures for ${{ github.repository }}\n\n"
                  md+="Triggered: ${{ github.event.workflow_run.run_started_at }} • [Run link](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }})\n\n"
                  found_any=0
                  for f in downloaded/**/failures.json; do
                    found_any=1
                    failed=$(jq -r '.summary.failed // 0' "$f" 2>/dev/null || echo 0)
                    total=$(jq -r '.summary.total // 0' "$f" 2>/dev/null || echo 0)
                    job=$(jq -r '.jobName // empty' "$f" 2>/dev/null || echo "")
                    [ -z "$job" ] && job=$(basename "$(dirname "$f")")
                    runUrl=$(jq -r '.links.runUrl // empty' "$f" 2>/dev/null || echo "")
                    total_failed=$((total_failed+failed))
                    total_suites=$((total_suites+1))
                    md+="- ${job}: ${failed}/${total} failed"
                    if [ -n "$runUrl" ]; then
                      md+=" — [run](${runUrl})"
                    fi
                    md+="\n"
                  done
                  if [ $found_any -eq 0 ]; then
                    md+="No failures.json artifacts were found to summarize.\n"
                  else
                    md+="\nTotal failed tests across ${total_suites} matrix jobs: ${total_failed}\n"
                  fi
                  printf "%b" "$md" > summary.md
                  echo "summary_path=$(pwd)/summary.md" >> "$GITHUB_OUTPUT"
                  echo "total_failed=${total_failed}" >> "$GITHUB_OUTPUT"

            - name: Find or create rolling failure issue
              id: ensure_issue
              uses: actions/github-script@v7
              env:
                  SUMMARY_PATH: ${{ steps.aggregate.outputs.summary_path }}
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const fs = require('fs');
                      const body = fs.readFileSync(process.env.SUMMARY_PATH, 'utf8');
                      const marker = '<!-- run:${{ github.event.workflow_run.id }} -->';
                      const {owner, repo} = context.repo;
                      const label = 'ci-failure';
                      const title = 'Nightly CI failures: C# tests';

                      // Ensure label exists? Assume it's created manually as per repo policy.
                      const {data: issues} = await github.rest.issues.listForRepo({
                        owner, repo, state: 'open', labels: label, per_page: 100
                      });
                      let issue = issues.find(i => i.title === title);

                      if (!issue) {
                        const created = await github.rest.issues.create({
                          owner, repo, title, body, labels: [label]
                        });
                        core.setOutput('issue_number', String(created.data.number));
                        core.info(`Created issue #${created.data.number}`);
                        return;
                      }

                      // Avoid duplicate comments for the same run using marker
                      const {data: comments} = await github.rest.issues.listComments({
                        owner, repo, issue_number: issue.number, per_page: 100
                      });
                      const exists = comments.some(c => c.body && c.body.includes(marker));
                      if (!exists) {
                        await github.rest.issues.createComment({
                          owner, repo, issue_number: issue.number, body
                        });
                        core.info(`Commented on issue #${issue.number}`);
                      } else {
                        core.info('A comment for this run already exists; skipping.');
                      }
                      core.setOutput('issue_number', String(issue.number));
