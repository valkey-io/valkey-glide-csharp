name: C# failure reporter

on:
    workflow_run:
        workflows: ["C# tests"]
        types: [completed]
        branches: [jbrinkman/matrix-errors]

permissions:
    actions: read
    contents: read
    issues: write

jobs:
    report:
        # Only run this job when the triggering run failed and was schedule or workflow_dispatch
        if: ${{ github.event.workflow_run.conclusion == 'failure' && (github.event.workflow_run.event == 'schedule' || github.event.workflow_run.event == 'workflow_dispatch') }}
        runs-on: ubuntu-latest
        steps:
            - name: Download artifacts from triggering run
              uses: dawidd6/action-download-artifact@v6
              with:
                  run_id: ${{ github.event.workflow_run.id }}
                  path: downloaded

            - name: Aggregate failures
              id: aggregate
              shell: bash
              run: |
                  set -euo pipefail
                  sudo apt-get update -y >/dev/null 2>&1 || true
                  sudo apt-get install -y jq xmlstarlet >/dev/null 2>&1 || true
                  shopt -s nullglob

                  total_failed=0
                  total_legs=0
                  failing_legs=0
                  md='<!-- run:${{ github.event.workflow_run.id }} -->
                  '
                  md+="# Nightly CI failures for ${{ github.repository }}
                  "$'\n'
                  md+="Triggered: ${{ github.event.workflow_run.run_started_at }} • [Run link](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }})
                  "$'\n\n'
                  md_details=""

                  # Iterate each artifact folder downloaded
                  for dir in downloaded/*; do
                    [ -d "$dir" ] || continue
                    base="$(basename "$dir")"
                    case "$base" in
                      test-reports-*) ;;
                      *) continue ;;
                    esac
                    total_legs=$((total_legs+1))
                    job_display="$base"

                    # Prefer failures.json
                    fjson="$dir/failures.json"
                    failed=0; total=0
                    if [ -f "$fjson" ]; then
                      failed=$(jq -r '.summary.failed // 0' "$fjson" 2>/dev/null || echo 0)
                      total=$(jq -r '.summary.total // 0' "$fjson" 2>/dev/null || echo 0)
                    fi

                    # Fallback to TRX parse if counts are zero
                    if [ "$failed" = "0" ] && [ "$total" = "0" ]; then
                      trx=$(ls "$dir"/*.trx 2>/dev/null | head -n1 || true)
                      if [ -n "$trx" ]; then
                        total=$(xmlstarlet sel -T -t -v 'string(//*[local-name()="Counters"]/@total)' "$trx" 2>/dev/null || echo 0)
                        failed=$(xmlstarlet sel -T -t -v 'string(//*[local-name()="Counters"]/@failed)' "$trx" 2>/dev/null || echo 0)
                      fi
                    fi

                    # Emit only failing legs with per-test bullets
                    if [ "$failed" != "0" ]; then
                      failing_legs=$((failing_legs+1))
                      total_failed=$((total_failed+failed))
                      md+="- ${job_display}: ${failed}/${total} failed\n"
                      # Try to get failed tests either from failures.json or directly from TRX
                      bullets=""
                      if [ -f "$fjson" ]; then
                        bullets=$(jq -r '.failed[]? | "  - " + (.displayName // .fullyQualifiedName // .name // "(unknown)") + (if .errorMessage then " — " + .errorMessage else (if .message then " — " + .message else "" end) end)' "$fjson" 2>/dev/null || true)
                      fi
                      if [ -z "$bullets" ]; then
                        if [ -n "${trx:-}" ] && [ -f "$trx" ]; then
                          while IFS= read -r line; do
                            name="${line%%||*}"
                            msg="${line#*||}"
                            # Trim to first line and limit length
                            msg="${msg%%$'\n'*}"
                            if [ ${#msg} -gt 200 ]; then msg="${msg:0:197}..."; fi
                            echo "  - ${name} — ${msg}"
                          done < <(xmlstarlet sel -T -t -m '//*[local-name()="UnitTestResult" and @outcome="Failed"]' -v 'concat(@testName,"||", normalize-space(.//*[local-name()="Message"]))' -n "$trx" 2>/dev/null || true) > "$dir/.bullets.txt"
                          bullets=$(cat "$dir/.bullets.txt" 2>/dev/null || true)
                        fi
                      fi
                      if [ -n "$bullets" ]; then
                        md_details+=$'\n'
                        md_details+="### ${job_display}\n\n"
                        md_details+="$bullets\n"
                      fi
                    fi
                  done

                  if [ "$failing_legs" = "0" ]; then
                    md+="The pipeline failed, but no individual test failures were found. This may indicate a job or infrastructure failure.\n"
                  fi
                  md+=$'\n'
                  md+="Total failed tests across ${failing_legs} of ${total_legs} matrix jobs: ${total_failed}\n\n"
                  md+="$md_details"

                  printf "%b" "$md" > summary.md
                  echo "summary_path=$(pwd)/summary.md" >> "$GITHUB_OUTPUT"
                  echo "total_failed=${total_failed}" >> "$GITHUB_OUTPUT"
                  echo "total_legs=${total_legs}" >> "$GITHUB_OUTPUT"

            - name: Find or create rolling failure issue
              id: ensure_issue
              uses: actions/github-script@v7
              env:
                  SUMMARY_PATH: ${{ steps.aggregate.outputs.summary_path }}
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const fs = require('fs');
                      const body = fs.readFileSync(process.env.SUMMARY_PATH, 'utf8');
                      const marker = '<!-- run:${{ github.event.workflow_run.id }} -->';
                      const {owner, repo} = context.repo;
                      const label = 'ci-failure';
                      const title = 'Nightly CI failures: C# tests';

                      // Ensure label exists? Assume it's created manually as per repo policy.
                      const {data: issues} = await github.rest.issues.listForRepo({
                        owner, repo, state: 'open', labels: label, per_page: 100
                      });
                      let issue = issues.find(i => i.title === title);

                      if (!issue) {
                        const created = await github.rest.issues.create({
                          owner, repo, title, body, labels: [label]
                        });
                        core.setOutput('issue_number', String(created.data.number));
                        core.info(`Created issue #${created.data.number}`);
                        return;
                      }

                      // Avoid duplicate comments for the same run using marker
                      const {data: comments} = await github.rest.issues.listComments({
                        owner, repo, issue_number: issue.number, per_page: 100
                      });
                      const exists = comments.some(c => c.body && c.body.includes(marker));
                      if (!exists) {
                        await github.rest.issues.createComment({
                          owner, repo, issue_number: issue.number, body
                        });
                        core.info(`Commented on issue #${issue.number}`);
                      } else {
                        core.info('A comment for this run already exists; skipping.');
                      }
                      core.setOutput('issue_number', String(issue.number));
